package net.bordnerd.exparse {		// The following "shunting yard" algorithm was probably developed by	// Edsger Dijkstra circa 1960.  Its approach in parsing expressions through	// recursive descent was outlined in an essay by Theodore Norvel.	//	// http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm		import net.bordnerd.exparse.*;	import net.bordnerd.exparse.console.*;	import net.bordnerd.exparse.functiontable.*;	import net.bordnerd.exparse.ops.*;	import net.bordnerd.exparse.ops.bin.*;	import net.bordnerd.exparse.ops.un.*;	import net.bordnerd.exparse.terms.*;	import net.bordnerd.exparse.terms.logic.*;	import net.bordnerd.exparse.dynamicvars.*;	import net.bordnerd.exparse.event.EventManager;		//	//		//	exparse class hierarchy (all classes are also ExpressionParser objects so that they can use parse methods)	//		//	--------------------	//	| ExpressionParser |	//	--------------------	//	/\	//	 |    ------------------	//	 | <- | Operator       |	//	 |    ------------------	//	 |    /\	//	 |     |    ------------------	//	 |     | <- | BinaryOperator |	//	 |     |    ------------------	//	 |     |    /\	//	 |     |     |_ { Operator_MUL, Operator_DIV, Operator_MOD, Operator_ADD, Operator_SUB,	//	 |     |            Operator_CAT, Operator_LT, Operator_GT, Operator_LE, Operator_GE,	//	 |     |            Operator_EQ, Operator_NE, Operator_AND, Operator_OR, Operator_XOR, Operator_ASGN }	//	 |     |	//	 |     |    -----------------	//	 |     | <- | UnaryOperator |	//	 |     |    -----------------	//	 |     |    /\	//	 |     *     |_ { Operator_NOT, Operator_RETURN }	//	 |     	//	 |    ------------------	//	 | <- | Terminal       |	//	 |    ------------------	//	 |    /\	//	 |     |_ { BlockStatement, FunctionCall, IfElse, Variable, While, ArrayMapElement, ArrayMapLiteral, FunctionExpression  }*	//	 |     |	//	 |     |   ----------------	//	 |     |<- | Constant     |	//	 |     |   ----------------	//	 |     |   /\	//	 |     |    |_ { BooleanConstant, NumberConstant, StringConstant }	//	 |     |    |	//	 |     |    |  -----------------------	//	 |     |    |<-| KeywordConstant     |	//	 |     |       -----------------------	//	 |     *       /\	//	 |              |_ { NullKeywordConstant }	//	 |	//	 |	//	 *	//			//		 * Some Terminals aren't so much expressions, but are containers of expressions such as: BlockStatement, IfElse, While, FunctionExpression etc.	//		 	//		/**	 * @author michael.bordner	 * @version 1.0	 * 	 * <p>ExpressionParser is a simple expression parser based on the shunting yard algorithm for recursive decent parsing.	 * It excels at simple expressions, but has a framework for basic logic structure parsing as well.  The parser uses a singleton	 * data provider which will allow multiple expressions to continue with previous data values stored as variables.</p>	 * 	 * @see DataProvider 	 */	public class ExpressionParser {				/**		 * Hash map between operator tokens and their definitions.		 */				private static var objOperatorMap:Object = null;		private static function initalizeOperatorMap():void {			if( ExpressionParser.objOperatorMap == null ) {				ExpressionParser.objOperatorMap = { 					NOT : new OperatorDefinition(800,1,1),					MUL : new OperatorDefinition(700,2,0), DIV: new OperatorDefinition(700,2,0), MOD: new OperatorDefinition(700,2,0),					ADD : new OperatorDefinition(600,2,0), SUB: new OperatorDefinition(600,2,0), CAT: new OperatorDefinition(600,2,0),					LT  : new OperatorDefinition(500,2,0), GT : new OperatorDefinition(500,2,0), LE : new OperatorDefinition(500,2,0),  GE : new OperatorDefinition(500,2,0),					EQ  : new OperatorDefinition(400,2,0), NE : new OperatorDefinition(400,2,0),					AND : new OperatorDefinition(300,2,0), OR : new OperatorDefinition(300,2,0), XOR: new OperatorDefinition(300,2,0),					ASGN: new OperatorDefinition(100,2,1), // alias for =					PROP: new OperatorDefinition(100,2,1), // alias for :					RETURN: new OperatorDefinition(1,1,1)				};			}		}				public static function getOperatorDefinition( strId:String ):OperatorDefinition {			return OperatorDefinition(objOperatorMap[ strId ]);			}				public static const WHITESPACE:String = " \t\r\n";							public static const WHITESPACEANDTOKENS:String = " \t\r\n(),={}:[];";							private static var objDataProvider:DataProvider = null;				private var objLocalDataProvider:LocalDataProvider = null;				protected var arrRootNode:Array = null; // of ExpressionParser		private var strErrorMsg:String = null;		protected var numConsumption:Number = -1;						private var strExpression:String = null;		private var numIStart:Number = 0;		private var numIEnd:Number = 0;		private var strNextToken:String = null;		private var EOE:Boolean = false;		private var arrExprChars:Array = null;				private var arrOperators:Array = null;		private var arrOperands:Array = null;				private var objReturnValue:Object = null;		private var boolReturnedValue:Boolean = false;		private var boolTopLevelParser:Boolean = false;				/**		 * @param strExpression optional expression to parse.  The expression is not required at construction.		 * @see ExpressionParser.parse		 */		public function ExpressionParser( strExpression:String = null ) {			ExpressionParser.initalizeOperatorMap();						if( strExpression != null ) {				if( !( strExpression is String ) ) {					strExpression = new String( strExpression );					}				if( strExpression.length > 0 ) {					this.parse( strExpression );					}							}							}				/**		 * @param strExpression expression to parse.		 * <p>It may be useful to use the same ExpressionParser to parse multiple expressions. This method can be called for each expression to parse.</p>		 * @return Boolean, true if the expression successfully parsed, false otherwise.		 */		public function parse( strExpression:String ):Boolean {			//trace("--------------------------------==--==--");			//trace( strExpression );			//trace("--------------------------------==--==--");			strExpression = this.removeComments( strExpression );			//trace( strExpression );			//trace("--------------------------------==--==--");						this.boolTopLevelParser = true;						return this.parseS( strExpression );			}				/**		 * @return array of expression parser objects that represent the statement list of the parsed expression		 */		public function getParsedExpressions():Array {			return this.arrRootNode.slice(0);			}			/**		 * @return true if last expression parsed had errors, false otherwise.		 * <p>This method should not be called before parse is called on the ExpressionParser.		 */		public function wasError():Boolean {			return ( this.strErrorMsg != null );			}				/**		 * @return parse error msg as a String if there was an error, otherwise null		 */		public function getErrorMsg():String {			return this.strErrorMsg;			}				public function getConsumption():Number {			return this.numConsumption;			}				/**		 * @return Array of variable identifiers that exist in the parsed expression.		 */		public function getVariables( objHash:Object = null, objRootParser:ExpressionParser = null, objDataProvidingParser:ExpressionParser = null ):Array {			if( objRootParser == null ) {				objRootParser = this;				}			if( objDataProvidingParser == null ) {				objDataProvidingParser = this;			}			var arrVariables:Array = new Array();			if( objHash == null ) {				if( this.arrRootNode != null ) {					objHash = new Object();					for( var i:uint = 0; i < this.arrRootNode.length; ++i ) {						this.arrRootNode[i].getVariables(objHash,objRootParser,objDataProvidingParser);						}					for( var p:String in objHash ) {						arrVariables.push( p );						}				}							}			return arrVariables;		}				/**		 * @return Array of variable identifiers that would be modified if the expression is evaluated.		 */		public function getLValues( objHash:Object = null, objRootParser:ExpressionParser = null, objDataProvidingParser:ExpressionParser = null ):Array {			if( objRootParser == null ) {				objRootParser = this;				}			if( objDataProvidingParser == null ) {				objDataProvidingParser = this;			}			var arrLValues:Array = new Array();			if( objHash == null ) {							if( this.arrRootNode != null ) {					objHash = new Object();					for( var i:uint = 0; i < this.arrRootNode.length; ++i ) {						this.arrRootNode[i].getLValues(objHash,objRootParser,objDataProvidingParser);						}					for( var p:String in objHash ) {						arrLValues.push( p );						}				}							}			return arrLValues;				}				/**		 * This method destroys any script functions that would have been created by the parsed expression when evaluated.		 */		public function destroyFunctions():void {			if( this.arrRootNode != null ) {				for( var i:uint = 0; i < this.arrRootNode.length; ++i ) {					if( this.arrRootNode[i] is FunctionExpression ) {						ExpressionParser.removeFunction( FunctionExpression(this.arrRootNode[i]).getIdentifier() );						}					}				}		}				/**		 * @return the evaluation of the expression, if the expression was a list of expressions separated by "," then the last expression evaluation is returned.		 */		public function evaluate( objRootParser:ExpressionParser = null, objDataProvidingParser:ExpressionParser = null ):Object {			if( objRootParser == null ) {				objRootParser = this;				}			if( objDataProvidingParser == null ) {				objDataProvidingParser = this;				}			return this.evaluateExpressions( objRootParser, objDataProvidingParser ).pop();			}				/**		 * @return Array of expression evaluations.  Each expression in the list (separated by ",") is evaluated and returned in the array.		 */		public function evaluateExpressions( objRootParser:ExpressionParser = null, objDataProvidingParser:ExpressionParser = null ):Array {			if( objRootParser == null ) {				objRootParser = this;				}			if( objDataProvidingParser == null ) {				objDataProvidingParser = this;			}						// initialize return value to undefined;			this.clearReturnValue();							var arrValues:Array = new Array();			if( this.arrRootNode != null ) {				for( var i:uint = 0; i < this.arrRootNode.length; ++i ) {					if( this.arrRootNode[i] != undefined ) {						arrValues[i] = this.arrRootNode[i].evaluate( objRootParser, objDataProvidingParser );						if( this.arrRootNode[i] is Operator_RETURN ) {							this.setReturnValue( arrValues[i] );							break;							} else {							if( this.arrRootNode[i].hadReturnValue() ) {								this.setReturnValue( this.arrRootNode[i].getReturnValue() );								break;								}											}					} else {						arrValues.push( this.arrRootNode[i] );						}				}			}			return arrValues;		}				/**		 * @return return value from RETURN operator if encountered		 */		public function getReturnValue():Object {			if( this.hadReturnValue() ) {				return this.objReturnValue;			}			return undefined;			}				/**		 * @return true if had RETURN operator		 */		public function hadReturnValue():Boolean {			return this.boolReturnedValue;			}			/**		 * Clears return values.  This method is used at the start of evaluateExpressions()		 */		protected function clearReturnValue():void {			this.boolReturnedValue = false;			this.objReturnValue = undefined;		}			/**		 * Caches the return value, and flags that there was a RETURN.		 */		protected function setReturnValue( objValue:Object ):void {			this.boolReturnedValue = true;			this.objReturnValue = objValue;			}				/**		 * @return string of the expression with paranthesis inserted to show precedence.		 */		public function toString():String {			if( this.wasError() ) {				return this.getErrorMsg();			}			if( this.arrRootNode != null ) {				var strValue:String = "";				for( var i:uint = 0; i < this.arrRootNode.length; ++i ) {					if( strValue != "" ) {						strValue += ",";					}					strValue += "( " + this.arrRootNode[i].toString() + " )";				}				return strValue;			}			return "";		}				/**		 * Removes single line and multi-line comments (as in ActionScript) from strExpression.		 * @param strExpression String string that will have comments removed.		 * @return String strExpression with comments removed		 */		private function removeComments( strExpression:String ):String {			if( strExpression != null && strExpression.length > 0 ) {				if( strExpression.indexOf("//") != -1 || strExpression.indexOf("/*") != -1 ) {					var arrPieces:Array = new Array();					var arrChars:Array = strExpression.split("");									var numStart:Number = 0;					for( var i:uint = 0; i < arrChars.length; ++i ) {						if( arrChars[i] == "'" ) { // entering a string value, ignore all comments in string value and advance to the end of the string							while( ++i < arrChars.length ) {								if( arrChars[i] == "'" ) {									if( (i+1) < arrChars.length && arrChars[i+1] == "'" ) {										++i; // this is an escaped quote.									} else {										break;										}									}								}						} else if( arrChars[i] == "/" ) {							var boolWasComment:Boolean = false;							var numEnd:Number;							if( arrChars[i+1] == "/" ) {								boolWasComment = true;								for( numEnd = i+2; numEnd < arrChars.length; ++numEnd ) {									if( arrChars[numEnd] == "\n" || arrChars[numEnd] == "\r" ) {										--numEnd;										break;										}									}							} else if( arrChars[i+1] == "*" ) {								boolWasComment = true;								for( numEnd = i + 2; numEnd < arrChars.length; ++numEnd ) {									if( arrChars[numEnd] == "*" ) {										if( arrChars[numEnd+1] == "/" ) {											++numEnd;											break;										}										}									}							}							if( boolWasComment ) {								arrPieces.push( strExpression.substring( numStart, i ) );								numStart = numEnd + 1;								i = numStart - 1;							}							}						}					arrPieces.push( strExpression.substr(numStart) );					strExpression = arrPieces.join("");				}			}			return strExpression;			}				public static function findGroupClose( arrChars:Array, numStart:Number, strOpen:String, strClose:String, boolSkipStringValues:Boolean = true ):Number {			var numEnd:Number = numStart;			var numGroups:Number = 1;			while( numGroups > 0 && ++numEnd < arrChars.length ) {				if( boolSkipStringValues && arrChars[numEnd] == "'" ) {					numEnd = findStringClose( arrChars, numEnd );				} else if( arrChars[numEnd] == strOpen ) {					++numGroups;				} else if( arrChars[numEnd] == strClose ) {					--numGroups;					}				}			if( numEnd == arrChars.length ) {				return -1;			}			return numEnd;							}				public static function findStringClose( arrChars:Array, numStart:Number ):Number {			var numEnd:Number = -1;			if( arrChars[numStart] == "'" ) {				var numCurrentQuoteChar:Number = numStart;				do {					for( numEnd = numCurrentQuoteChar + 1; numEnd < arrChars.length && arrChars[numEnd] != "'"; ++numEnd ) {					}					numCurrentQuoteChar = numEnd + 1;				} while( numCurrentQuoteChar < arrChars.length && arrChars[numCurrentQuoteChar] == "'" );// skip past escpaed quotes ('')			}			return numEnd;		}				/**		 * This method looks ahead in arrChars starting at numIStart, and finds the first non whitespace		 */		public static function lookAhead( arrChars:Array, numIStart:Number ):Number {			while( numIStart < arrChars.length && ExpressionParser.WHITESPACE.indexOf( arrChars[numIStart] ) != -1 ) {				++numIStart;				}					return numIStart;		}				/**		 * This method finds the first occurrance of a character in strEndChars starting at numIndexStart		 */		public static function findStart( arrChars:Array, numIndexStart:Number, strEndChars:String ):Number {			while( 				numIndexStart < arrChars.length && 				strEndChars.indexOf( arrChars[++numIndexStart] ) == -1 			) {};			return numIndexStart;		}						protected function error( strMsg:String ):void {			if( this.strErrorMsg == null ) {				this.strErrorMsg = strMsg;				} else {				this.strErrorMsg += " : " + strMsg;				}		}				private function expect( ...arrArguments:Array ):Boolean {			var boolExpectedFound:Boolean = false;			var i:uint = 0;			for( i = 0; i < arrArguments.length; ++i ) {				if( this.strNextToken == arrArguments[i] ) {					boolExpectedFound = true;					break;					}				}			if( boolExpectedFound ) {				this.consume();				return true;				} else {				var strExpected:String = "";				if( arrArguments.length > 1 ) {					strExpected = "either: ";					for( i = 0; i < arrArguments.length; ++i ) {						if( i > 0 ) {							strExpected += " or ";							}						strExpected += ( arrArguments[i] != null ) ? "'" + ExpressionParser.escapeString(arrArguments[i]) + "'" : "[end of expression]";					}					} else {					strExpected = arrArguments[0];				}				this.error( "Expected [" + strExpected + "], Found: ['" + ExpressionParser.escapeString(this.strNextToken) + "']");				return false;				}			}				private function compareOps( strOp1:String, strOp2:String ):Number {			if( strOp1 != null ) { // null is our sentinel stack marker				if( strOp2 != null ) { // strOp2 should never be this, since we are passing in op to compare (strOp2) with top of stack (strOp1)									var op1t:Number = OperatorDefinition(ExpressionParser.objOperatorMap[strOp1]).t;//binary if t = 2, unary if t = 1					var op2t:Number = OperatorDefinition(ExpressionParser.objOperatorMap[strOp2]).t;					var op1p:Number = OperatorDefinition(ExpressionParser.objOperatorMap[strOp1]).p; // precedence, 					var op2p:Number = OperatorDefinition(ExpressionParser.objOperatorMap[strOp2]).p;					var op1a:Number = OperatorDefinition(ExpressionParser.objOperatorMap[strOp1]).a; // 0 = left associative, 1 = right					//var op2a:Number = OperatorDefinition(ExpressionParser.objOperatorMap[strOp2]).a;										if( op1t == 1 ) { // if op1 is unary						if( op2t == 2 ) { // if op2 is binary							if( op1p > op2p ) {								return 1; // op1 has higher precedence							} else if( op1p == op2p ) {								return 0; // op1 has same precedence							}						} // if op2 is unary also, op2 will always be greater					} else { // else op1 is binary						if( op2t == 2 ) { // if op2 is binary							if( op1p > op2p ) {								return 1; // op1 has higher precedence							} else if( op1a == 0 && op1p == op2p ) {								return 0; // op1 has same precedence, or op1 is left associative							}						} 					}				} else {					return 1; // should never happen... op2 SHOULD not be sentinel				}			}			return -1; // op1 is sentinel, or op2 is unary, or op2 had greater precedence, or op1 is right associative						}				public static function escapeString( strValue:String ):String {			if( strValue != null ) {				return strValue.split("'").join("''");			}			return null;		}				public static function unescapeString( strValue:String ):String {			if( strValue != null ) {				return strValue.split("''").join("'");				}			return null;		}				protected function castNumber( strValue:String ):Number {			if( strValue != null ) {				var tmpValue:Number = parseFloat( strValue );				if( !isNaN( tmpValue ) ) {					return tmpValue;					}				}			return 0;			}				protected function castBoolean( strValue:String ):Boolean { 			if( strValue != null ) { // null is false				if( strValue.length > 0 ) { // empty string is false					var tempValue:String = strValue.toLowerCase();					if( tempValue == "true" ) {						return true;					}				}							}			return false;		}				private function isBooleanConstant( strValue:String ):Boolean {			if( strValue != null && strValue.length > 0 ) {				var strValueLowerCase:String = strValue.toLowerCase();				if( strValueLowerCase == "true" || strValueLowerCase == "false" ) {					return true;				} 			}			return false;			}				private function isStringConstant( strValue:String ):Boolean {			if( strValue != null && strValue.length > 0 ) {				var firstChar:String = strValue.charAt(0);				var lastChar:String = strValue.charAt(strValue.length-1);				if( firstChar == "'" && lastChar == "'" ) {					return true;				}			}			return false;			}				private function isNumberConstant( strValue:String ):Boolean {			if( strValue != null && strValue.length > 0 ) {				if( !isNaN( parseFloat( strValue ) ) ) {					return true;				} 			}			return false;			}				private function isConstant( strValue:String ):Boolean {			if( this.isBooleanConstant(strValue) 				|| this.isStringConstant(strValue) 				|| this.isNumberConstant(strValue) ) {				return true;			}			return false;		}				/*		private function isVarIdentifier( strValue:String ):Boolean {			return (!this.isConstant( strValue ) && strValue.charAt(strValue.length-1)!=")" );		}		*/				private function isKeywordConstant( strValue:String ):Boolean {			var strTmpValue:String = strValue.toUpperCase();			switch( strTmpValue ) {				case "NULL":					return true;			}			return false;		}				private function isLogicStructure( strValue:String ):Boolean {			var strTmpValue:String = strValue.toUpperCase();			switch( strTmpValue ) {				case "IF":					return true;				case "FUNCTION":					return true;				case "WHILE":					return true;			}			return false;		}				private function isOperator( strOp:String ):Boolean {			if( strOp != null ) {				return ( ExpressionParser.objOperatorMap[strOp] != undefined ) ? true : false;			}			return false;		}				private function isBinaryOperator( strOp:String ):Boolean {			if( strOp != null ) {				if( ExpressionParser.objOperatorMap[strOp] != undefined ) {					var objOp:OperatorDefinition = OperatorDefinition(ExpressionParser.objOperatorMap[strOp]);					return ( objOp.t == 2 ) ? true : false;				}			}			return false;		}				private function isUnaryOperator( strOp:String ):Boolean {			if( strOp != null ) {				if( ExpressionParser.objOperatorMap[strOp] != undefined ) {					var objOp:OperatorDefinition = OperatorDefinition(ExpressionParser.objOperatorMap[strOp]);					return ( objOp.t == 1 ) ? true : false;				}			}			return false;		}				private function consumeIf( ...arrArguments:Array ):void {			for( var i:uint = 0; i < arrArguments.length; ++i ) {				if( this.strNextToken == arrArguments[i] ) {					this.consume();					break;					}				}			}				private function isInvalidTerminalStart( strValue:String ):Boolean {			strValue = strValue.toLowerCase();			switch( strValue ) {				case "else":							return true;					}			return false;		}				private function createBinaryOperator( strOperator:String, objTerm1:ExpressionParser, objTerm2:ExpressionParser ):BinaryOperator {			switch( strOperator ) {				case "MUL":					return new Operator_MUL( objTerm1, objTerm2 );				case "DIV":					return new Operator_DIV( objTerm1, objTerm2 );				case "MOD":					return new Operator_MOD( objTerm1, objTerm2 );				case "ADD":					return new Operator_ADD( objTerm1, objTerm2 );				case "SUB":					return new Operator_SUB( objTerm1, objTerm2 );				case "CAT":					return new Operator_CAT( objTerm1, objTerm2 );				case "LT":					return new Operator_LT( objTerm1, objTerm2 );				case "GT":					return new Operator_GT( objTerm1, objTerm2 );				case "LE":					return new Operator_LE( objTerm1, objTerm2 );				case "GE":					return new Operator_GE( objTerm1, objTerm2 );				case "EQ":					return new Operator_EQ( objTerm1, objTerm2 );				case "NE":					return new Operator_NE( objTerm1, objTerm2 );				case "AND":					return new Operator_AND( objTerm1, objTerm2 );				case "OR":					return new Operator_OR( objTerm1, objTerm2 );				case "XOR":					return new Operator_XOR( objTerm1, objTerm2 );				case "ASGN":					return new Operator_ASGN( objTerm1, objTerm2 );				case "PROP":					return new Operator_PROP( objTerm1, objTerm2 );					}			return null;			}			private function createUnaryOperator( strOperator:String, objTerm1:ExpressionParser ):ExpressionParser {			switch( strOperator ) {				case "NOT":					return new Operator_NOT( objTerm1 );				case "RETURN":					return new Operator_RETURN( objTerm1 );			}				return null;		}				private function createKeywordConstant( strKeyword:String ):ExpressionParser {			switch( strKeyword ) {				case "NULL":					return new NullKeywordConstant();			}			return null;		}				private function createLogicStructure( strLogicStructureName:String, strBody:String ):ExpressionParser {			switch( strLogicStructureName ) {				case "IF":					return new IfElse( strBody );				case "WHILE":					return new While( strBody );				case "FUNCTION":					return new FunctionExpression( strBody );			}			return null;		}					private function popOperator( arrOperators:Array, arrOperands:Array ):void {			var strTop:String = arrOperators[arrOperators.length-1];			var objTerm1:ExpressionParser = null;			var objTerm2:ExpressionParser = null;			var objTree:ExpressionParser = null;						if( this.isBinaryOperator( strTop ) ) {				objTerm2 = ExpressionParser( arrOperands.pop() );				objTerm1 = ExpressionParser( arrOperands.pop() );								objTree = this.createBinaryOperator( strTop, objTerm1, objTerm2 );				if( objTree != null ) {					arrOperands.push( objTree );				} else {					this.error("no support for binary operator: "+strTop);					}								arrOperators.pop();							} else if( this.isUnaryOperator( strTop ) ) {				objTerm1 = ExpressionParser( arrOperands.pop() );								objTree = this.createUnaryOperator( strTop, objTerm1 );				if( objTree != null ) {					arrOperands.push( objTree );				} else {					this.error("no support for unary operator: "+strTop);					}								arrOperators.pop();			}		}				private function pushOperator( strOperator:String, arrOperators:Array, arrOperands:Array ):void {			var strTop:String = arrOperators[arrOperators.length-1];			strOperator = strOperator.toUpperCase();			while( this.compareOps( strTop, strOperator ) >= 0 ) {				this.popOperator( arrOperators, arrOperands );				strTop = arrOperators[arrOperators.length-1];			}			arrOperators.push( strOperator );		}				// this method assumes that the following properties are available and initialized to current state		//		strExpression : (string) full string of expression being parsed		//		arrExprChars :	(array) array of strings where each eliminate has a string of the expression character		//					equivalent to:  expression.charAt(index)		//		strNextToken :	(string) current token		//		numIStart : (number) start index of nextToken with in expression		//		numIEnd : (number) end index of nextToken with inexpression (last character index of nextToken + 1 with in expression)		//				equivalent to: iStart + nextToken.length		//		// after calling consume, nextToken will be a string of the next token of expression being analyzed:		// 		<token> ::= "(" | ")" | "," | <operator string> | <terminal>		//		<terminal> ::= <identifier string> | <constant value string> | <function call> | <logic structure>		// 		<operator string> ::= "NOT" | "MUL" | "DIV" | "MOD" | "ADD" | "SUB" | "CAT" | "LT" | "GT" | "LE" | "GE" | "EQ" | "NE" | "AND" | "OR" | "XOR" | "ASGN" | "="		// 		<constant value string> ::= ("'".*"'") | {"-"}[0..9]*{.}[0..9]* | "true" | "false"		// 		<identifier string> ::= [ "_" | ([a..z]|[A..Z])([<alpha numeric>]|"_")*		//		<function call> ::= <identifier string>"(".*")"		// 		<alpha numeric> ::= ( [a..z] | [A..Z] | [0..9] )			//			private function consume( numCharCount:Number = -1 ):void {			if( numCharCount == -1 ) {								this.strNextToken = null;				this.numIStart = this.numIEnd;								// skip start and end past any white space, and point them to the next token				this.numIEnd = this.numIStart = ExpressionParser.lookAhead( this.arrExprChars, this.numIStart );								if( this.numIStart < this.strExpression.length ) {					if( this.arrExprChars[this.numIStart] == ';' ) {						++this.numIEnd;						this.strNextToken = ",";						return;					} else if( this.arrExprChars[this.numIStart] == '=' ) {						++this.numIEnd;						this.strNextToken = "ASGN";						return;					} else if( this.arrExprChars[this.numIStart] == ':' ) {						++this.numIEnd;						this.strNextToken = "PROP";						return;					} else if( 						this.arrExprChars[this.numIStart] == '(' || 						this.arrExprChars[this.numIStart] == ')' ||						this.arrExprChars[this.numIStart] == ',' ||						this.arrExprChars[this.numIStart] == '[' ||						this.arrExprChars[this.numIStart] == ']' 					) {						++this.numIEnd;// set end to point past next token					} else if( this.arrExprChars[this.numIStart] == "'" ) {// look for string constant						this.numIEnd = ExpressionParser.findStringClose( this.arrExprChars, this.numIStart ) + 1;					} else {						//						// this token will either be:						//		Operator,						//		Constant (number, boolean or keyword constant value),						// 		Variable Identifier						//		(start of a ) Function Call,						// or 	(start of a ) Logic Structure						//																		this.numIEnd = ExpressionParser.findStart( this.arrExprChars, this.numIEnd, WHITESPACEANDTOKENS );											}										this.strNextToken = this.strExpression.substring( this.numIStart, this.numIEnd );				}										} else {				this.numIEnd += numCharCount;				this.strNextToken = this.strExpression.substring( this.numIStart, this.numIEnd );			}					}				// this method will parse an expression phrase where a phrase is:		//		P -> v | c | "(" E ")" | U P | F | l		//		U -> "NOT"		//		F -> f "(" A ")"		//		A -> E { "," E }		//		//	c := any terminal constant (boolean,number,string)		//	v := any terminal variable identifier		//	f := any terminal function call		//  l := any logic structure		private function parseP( arrOperators:Array, arrOperands:Array ):Boolean {			var numClose:Number = -1;						if( this.strNextToken != null ) {								if( this.strNextToken == "," ) {										this.EOE = true;					return true;												} else if( this.strNextToken == "(" ) {					this.consume();					arrOperators.push(null);//mark stack with sentinel										if( !this.parseE( arrOperators, arrOperands ) ) {						return false;						}										if( !this.expect(")") ) {						return false;					}										arrOperators.pop();									} else if( this.isUnaryOperator( this.strNextToken.toUpperCase() ) ) {										this.pushOperator( this.strNextToken.toUpperCase(), arrOperators, arrOperands );					this.consume();					if( !this.parseP( arrOperators, arrOperands ) ) {						return false;						}									} else {					// expecting a terminal					if( this.arrExprChars[this.numIStart] == '}' ||						this.arrExprChars[this.numIStart] == ')'					) {						this.error("Expected start for closing "+this.strExpression.substr(this.numIStart));						return false;						} else if( this.isInvalidTerminalStart( this.strNextToken ) ) {						this.error("Unexpected "+this.strNextToken);						return false;					} else if( this.arrExprChars[this.numIStart] == '{' ) {						// found block start						numClose = ExpressionParser.findGroupClose( this.arrExprChars, this.numIStart, "{", "}" );						if( numClose == -1 ) {							this.error("Expected closing }");							return false;							} else {							var objBlock:BlockStatement = new BlockStatement( strExpression.substring( this.numIStart, numClose + 1) ); 							if( objBlock.wasError() ) {								this.error( objBlock.getErrorMsg() );								return false;								}							arrOperands.push( objBlock );							// blocks imply an implied end statement							this.consume( numClose + 1 - this.numIEnd );							this.EOE = true;						}					} else if( this.arrExprChars[this.numIStart] == '[' ) {						// found ArrayMapLiteral start						numClose = ExpressionParser.findGroupClose( this.arrExprChars, this.numIStart, "[", "]" );						if( numClose == -1 ) {							this.error("Expected closing ]");							return false;						} else {							var objArrayMap:ArrayMapLiteral = new ArrayMapLiteral( strExpression.substring( this.numIStart, numClose + 1 ) ); 							if( objArrayMap.wasError() ) {								this.error( objArrayMap.getErrorMsg() );								return false;								}							arrOperands.push( objArrayMap );							this.consume( numClose + 1 - this.numIEnd );								}													} else if( this.isConstant( this.strNextToken ) ) {						if( this.isNumberConstant( this.strNextToken ) ) {							arrOperands.push( new NumberConstant( this.strNextToken ) );							} else if( this.isBooleanConstant( this.strNextToken ) ) {							arrOperands.push( new BooleanConstant( this.strNextToken ) );						} else { // string constant							arrOperands.push( new StringConstant( this.strNextToken.substr(1,this.strNextToken.length-2) ) );						}						} else if( this.isKeywordConstant( this.strNextToken ) ) {						arrOperands.push( this.createKeywordConstant( this.strNextToken.toUpperCase() ) );					} else {												// sanity check						var strTmpToken:String = this.strNextToken.toUpperCase();						if( false == this.isOperator( strTmpToken ) ) {														//							// this.nextToken will (should) either be:							// 		Variable Identifier							//		Function Call,							//		Array Map Element							// or 	Logic Structure							//							// we'll have to look ahead to find out							var numTmpStart:Number = ExpressionParser.lookAhead( this.arrExprChars, this.numIEnd );														if( this.isLogicStructure( strTmpToken ) ) {																var strBody:String = this.strExpression.substring( numTmpStart );								var objLogicStructure:ExpressionParser = this.createLogicStructure( strTmpToken, strBody );																if( objLogicStructure != null ) {									if( objLogicStructure.wasError() ) {										this.error( objLogicStructure.getErrorMsg() );										return false;									} else {										arrOperands.push( objLogicStructure );										this.consume( objLogicStructure.getConsumption() + numTmpStart - this.numIEnd );									}								} else {									this.error("No parser for logic structure: "+strTmpToken);									return false;								}																// logic structures should force and End of Expression condition (implied ,)								this.EOE = true;								} else {								if( numTmpStart < this.arrExprChars.length && this.arrExprChars[numTmpStart] == '(' ) {									//numTmpStart will be the start of the function call									var strFunctionName:String = this.strNextToken;//save function name									var objFunctionCall:FunctionCall = new FunctionCall( strFunctionName, this.strExpression.substring( numTmpStart ) );									if( objFunctionCall.wasError() ) {										this.error( objFunctionCall.getErrorMsg() );										return false;										}									arrOperands.push( objFunctionCall );									// consume all the remaing parts of the function call that were not already consumed.									//	where numTempStart - this.numIEnd == number of advancements to move the current this.numIEnd to the (									//  and objFunctionCall.getConsumption() == number of characters in the call [ ( char and ) char inclusive ]									this.consume( objFunctionCall.getConsumption() + ( numTmpStart - this.numIEnd ) );								} else if( numTmpStart < this.arrExprChars.length && this.arrExprChars[numTmpStart] == '[' ) {									// numTmpStart will be the start of an ArrayMapElement lookup									var strArrayMapName:String = this.strNextToken;// save array map name									var objArrayMapElement:ArrayMapElement = new ArrayMapElement( strArrayMapName, this.strExpression.substring( numTmpStart ) );									if( objArrayMapElement.wasError() ) {										this.error( objArrayMapElement.getErrorMsg() );										return false;										}									arrOperands.push( objArrayMapElement );									this.consume( objArrayMapElement.getConsumption() + ( numTmpStart - this.numIEnd ) );								} else {									var objHandler:DynamicVariableHandler = DynamicVariableTable.getInstance().getHandler( this.strNextToken );									if( objHandler != null ) {										arrOperands.push( new DynamicVariable( this.strNextToken, objHandler ) );									} else {										arrOperands.push( new Variable( this.strNextToken ) );									}									}															}																				} else {							this.error( "Unexpected operator" );							return false;						}															}					this.consume();					}					return true;							} else {				this.error( "Unexpected end of expression" );				return false;				}					}						// This method will parse the expression, where an expression is:		//		E -> P { B P }		//		B -> "ASGN"		//			| "="		//			| "OR" 		//			| "AND"		//			| "XOR" 		//			| "NE" 		//			| "EQ" 		//			| "GE" 		//			| "LE" 		//			| "GT" 		//			| "LT" 		//			| "CAT"		//			| "SUB"		//			| "ADD"		//			| "MOD"		//			| "DIV"		//			| "MUL"		private function parseE( arrOperators:Array, arrOperands:Array ):Boolean {			if( this.parseP( arrOperators, arrOperands ) ) {								while( !this.EOE && this.strNextToken != null && this.isBinaryOperator( this.strNextToken.toUpperCase() ) )  {					this.pushOperator( this.strNextToken.toUpperCase(), arrOperators, arrOperands );					this.consume();					if( !this.parseP( arrOperators, arrOperands ) ) {						return false;						}				}								var strTop:String = arrOperators[ arrOperators.length - 1 ];				while( strTop != null ) {					this.popOperator( arrOperators, arrOperands );					strTop = arrOperators[ arrOperators.length -1 ];					}								return true;			}			return false;				}				public function parseS( strExpression:String, numEToParse:Number = 0 ):Boolean {			this.strExpression = strExpression;					this.arrExprChars = strExpression.split("");			this.numIStart = 0;			this.numIEnd = 0;			this.strNextToken = null;			this.strErrorMsg = null;			this.EOE = false; // end of expression marker, used with logic structures			this.arrRootNode = null;						this.consume();						if( this.strNextToken != null ) { // if not at end							// initialize stacks				this.arrOperators = new Array(); // operators stack				this.arrOperands = new Array(); // operands stack								this.arrOperators.push(null); // push on a sentinel value (stack marker)							var numParsedE:Number = 0;								while( this.wasError() == false && this.strNextToken != null ) {					this.EOE = false;					if( this.parseE( this.arrOperators, this.arrOperands ) ) {						++numParsedE;						if( this.arrRootNode == null ) {							this.arrRootNode = new Array();							}												this.arrRootNode.push( this.arrOperands.pop() );// push new rootNode expression tree												// expect end of stream, or end of expression						if( numParsedE == numEToParse ) {							break;						} else if( this.EOE ) {							this.consumeIf(",");						} else if( !this.expect( ",", null ) ) {							break;							}										}									}						}						if( !this.wasError() ) {				this.numConsumption = this.numIStart;							} else {								if( this.boolTopLevelParser ) {					var strTmp:String = strExpression.substr( 0, this.numIStart + 1 );					var arrTmp:Array = strTmp.split("\r\n").join("\n").split("\r").join("\n").split("\n");					this.error( " [ line:"+arrTmp.length+", char:"+arrTmp[arrTmp.length -1].length+" ] ");				}											this.numConsumption = -1;				}								this.strExpression = null;			this.arrExprChars = null;			this.numIStart = 0;			this.numIEnd = 0;			this.strNextToken = null;			this.EOE = false;			this.arrOperators = null;			this.arrOperands = null;						return !this.wasError();		}						/**		 * Returns the data provider that for the ExpressionParser.		 */		public function get dataProvider():DataProvider {			if( this.objLocalDataProvider != null ) {				return this.objLocalDataProvider;				} else {				return ExpressionParser.getDataProvider();				}		}				/**		 * This method will return the LocalDataProvider instance if it was created.		 * @return LocalDataProvider if createLocalDataProvider() was called, otherwise null.		 */		public function get localDataProvider():LocalDataProvider {			return this.objLocalDataProvider;				}				/**		 * Allows other internal classes to pass their local data provider.		 */		public function set localDataProvider( objLocalDataProvider:LocalDataProvider ):void {			if( objLocalDataProvider != null ) {				this.objLocalDataProvider = objLocalDataProvider;				}			}				/**		 * By default ExpressionParser instances do not create local data providers, but if this method is called it will create a LocalDataProvider instance supplying the currently active Global DataProvider as the parent.		 */		public function createLocalDataProvider( dp:DataProvider = null ):LocalDataProvider {			if( dp == null ) {				dp = this.dataProvider;			}			this.objLocalDataProvider = new LocalDataProvider( dp );			return this.objLocalDataProvider;		}				/**		 * This method will insert a LocalDataProvider created externally into the expression data provider hierachy.  The current dataProvider will be		 * set as the passed in local data provider's parent provider.		 */		public function attachLocalDataProvider( ldp:LocalDataProvider ):void {			var dp:DataProvider = this.dataProvider;			this.objLocalDataProvider = ldp;			ldp.setParentDataProvider( dp );			}				/**		 * @return either DefaultDataProvider instance, or a DataProvider that was explicitly set to be the default DataProvider.		 */		public static function getDataProvider():DataProvider {			if( ExpressionParser.objDataProvider == null ) {				ExpressionParser.objDataProvider = new DefaultDataProvider();			}			return ExpressionParser.objDataProvider;			}				/**		 * This method should be called before any ExpressionParsers are used, as already created parsers would be using the default data provider.		 */		public static function setDataProvider( objDataProvider:DataProvider ):void {			ExpressionParser.objDataProvider = objDataProvider;			}				/**		 * Creates and returns a new DefaultDataProvider implementation typed as DataProvider.		 */		public static function createDataProvider():DataProvider {			return new DefaultDataProvider();			}				/**		 * @return Console instance to allow listeners to capture OUT() function calls in the expressions.		 */		public static function getConsole():Console {			return Console.getInstance();			}				/**		 * Adds a function reference to the FunctionTable to be evaluated in expressions.		 */		public static function addFunction( strIdentifier:String, objScope:Object, objFunction:Function ):void {			FunctionTable.getInstance().addFunction( strIdentifier, objScope, objFunction );		}				/**		 * Removes a function reference from the FunctionTable.		 */		public static function removeFunction( strIdentifier:String ):void {			FunctionTable.getInstance().removeFunction( strIdentifier );			}				/**		 * Adds a handler for a dynamic variable.  Any variables that match the prefix will be given the chance to be		 * evaluated by the handler instead of looking up a value from the data provider.		 */		public static function addDynamicVariableHandler( strPrefix:String, objHandler:DynamicVariableHandler ):void {			DynamicVariableTable.getInstance().addHandler( strPrefix, objHandler );		}				/**		 * Dispatches an event to listeners of the specific type. 		 * @param objEvent object, must have a string property named type that specificies the event type.  this property		 * 	is necessary to dispatch to the correct handlers.		 */		public static function dispatchScriptEvent( objEvent:Object ):void {			EventManager.getInstance().dispatchScriptEvent( objEvent );		}				/**		 * Registers a Table Function identifiable by the strHandlerFunctName to a specific string event type (strType)		 */		public static function addScriptEventListener( strType:String, strHandlerFunctionName:String ):void {			EventManager.getInstance().addScriptEventListener(strType, strHandlerFunctionName);			}				/**		 * Unregisters a Table Function identifiable by the strHandlerFunctName to a specific string event type (strType)		 */		public static function removeScriptEventListener( strType:String, strHandlerFunctionName:String ):void {			EventManager.getInstance().removeScriptEventListener(strType, strHandlerFunctionName);			}						/**		 * Replaces expressions wrapped with %, with evaluated values.  Percents can be escaped with double %%.  Percent chars in		 * string values that are in embedded expressions will be ignored.		 * 		 * @return string with any %expressions% replaced with their evaluated values.		 */		public static function replaceVars( str:String, dp:DataProvider = null ):String {			if( str.indexOf("%") != -1 ) {				var arrChars:Array = str.split("");				var arrTokens:Array = new Array();				var arrValues:Array = new Array();								var numIndex:uint = 0;				var numStart:uint = 0;								while( numIndex < arrChars.length ) {					if( arrChars[ numIndex ] == '%' ) {						if( arrChars[numIndex + 1] == '%' ) {							arrTokens.push('%');							++numIndex;						} else {														if( arrTokens.length > 0 ) {								arrValues.push( "'" + ExpressionParser.escapeString( arrTokens.join("") ) + "'" );							}							arrTokens = new Array();														++numIndex;							numStart = numIndex;							while( numIndex < arrChars.length && arrChars[numIndex] != '%' ) {								if( arrChars[ numIndex ] == "'" ) {									numIndex =	findStringClose( arrChars, numIndex );								}								++numIndex;							}														if( arrChars[ numIndex ] != '%' ) {								++numIndex;							}							arrValues.push( str.substring( numStart, numIndex ) );													}					} else {						arrTokens.push( arrChars[numIndex] );						}										++numIndex;					}								if( arrTokens.length > 0 ) {					arrValues.push( "'" + ExpressionParser.escapeString( arrTokens.join("") ) + "'" );				}								var ep:ExpressionParser = new ExpressionParser( arrValues.join( " CAT " ) );				ep.localDataProvider = ep.createLocalDataProvider(dp);								return String( ep.evaluate() );							}			return str;						}	}	}